/* istanbul ignore next */'use strict';Object.defineProperty(exports, "__esModule", { value: true });var _jsxFileName = '/Users/raja.d/GOR/gor.butler.ui.managerdashboard/src/components/rangeSlider/range.js'; /* eslint-disable react/prop-types */
var /* istanbul ignore next */_react = require('react'); /* istanbul ignore next */var _react2 = _interopRequireDefault(_react);
var /* istanbul ignore next */_classnames = require('classnames'); /* istanbul ignore next */var _classnames2 = _interopRequireDefault(_classnames);
var /* istanbul ignore next */_track = require('./common/track'); /* istanbul ignore next */var _track2 = _interopRequireDefault(_track);
var /* istanbul ignore next */_createSlider = require('./common/createSlider'); /* istanbul ignore next */var _createSlider2 = _interopRequireDefault(_createSlider);
var /* istanbul ignore next */_utils = require('./utils'); /* istanbul ignore next */var utils = _interopRequireWildcard(_utils); /* istanbul ignore next */function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

class Range extends /* istanbul ignore next */_react2.default.Component {



















  constructor(props) {
    super(props); /* istanbul ignore next */this.







































































    onEnd = () => {
      this.setState({ handle: null });
      this.removeDocumentEvents();
      this.props.onAfterChange(this.getValue());
    }; /* istanbul ignore next */const count = props.count,min = props.min,max = props.max;const initialValue = Array.apply(null, Array(count + 1)).map(() => min);const defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;const value = props.value !== undefined ? props.value : defaultValue;const bounds = value.map(v => this.trimAlignValue(v));const recent = bounds[0] === max ? 0 : bounds.length - 1;this.state = { handle: null, recent, bounds };}componentWillReceiveProps(nextProps) {if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return; /* istanbul ignore next */const bounds = this.state.bounds;const value = nextProps.value || bounds;const nextBounds = value.map(v => this.trimAlignValue(v, nextProps));if (nextBounds.length === bounds.length && nextBounds.every((v, i) => v === bounds[i])) return;this.setState({ bounds: nextBounds });if (bounds.some(v => utils.isValueOutOfRange(v, nextProps))) {this.props.onChange(nextBounds);}}onChange(state) {const props = this.props;const isNotControlled = !('value' in props);if (isNotControlled) {this.setState(state);} else if (state.handle !== undefined) {this.setState({ handle: state.handle });}const data = /* istanbul ignore next */Object.assign({}, this.state, state);const changedValue = data.bounds;props.onChange(changedValue);}onStart(position) {const props = this.props;const state = this.state;const bounds = this.getValue();props.onBeforeChange(bounds);const value = this.calcValueByPos(position);this.startValue = value;this.startPosition = position;const closestBound = this.getClosestBound(value);const boundNeedMoving = this.getBoundNeedMoving(value, closestBound);this.setState({ handle: boundNeedMoving, recent: boundNeedMoving });const prevValue = bounds[boundNeedMoving];if (value === prevValue) return;const nextBounds = [...state.bounds];nextBounds[boundNeedMoving] = value;this.onChange({ bounds: nextBounds });}

  onMove(e, position) {
    utils.pauseEvent(e);
    const props = this.props;
    const state = this.state;

    const value = this.calcValueByPos(position);
    const oldValue = state.bounds[state.handle];
    if (value === oldValue) return;

    const nextBounds = [...state.bounds];
    nextBounds[state.handle] = value;
    let nextHandle = state.handle;
    if (props.pushable !== false) {
      const originalValue = state.bounds[nextHandle];
      this.pushSurroundingHandles(nextBounds, nextHandle, originalValue);
    } else if (props.allowCross) {
      nextBounds.sort((a, b) => a - b);
      nextHandle = nextBounds.indexOf(value);
    }
    this.onChange({
      handle: nextHandle,
      bounds: nextBounds });

  }

  getValue() {
    return this.state.bounds;
  }

  getClosestBound(value) {/* istanbul ignore next */const
    bounds = this.state.bounds;
    let closestBound = 0;
    for (let i = 1; i < bounds.length - 1; ++i) {
      if (value > bounds[i]) {closestBound = i;}
    }
    if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
      closestBound += 1;
    }
    return closestBound;
  }

  getBoundNeedMoving(value, closestBound) {/* istanbul ignore next */var _state =
    this.state; /* istanbul ignore next */const bounds = _state.bounds,recent = _state.recent;
    let boundNeedMoving = closestBound;
    const isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];
    if (isAtTheSamePoint) {
      boundNeedMoving = recent;
    }

    if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
      boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
    }
    return boundNeedMoving;
  }

  getLowerBound() {
    return this.state.bounds[0];
  }

  getUpperBound() {/* istanbul ignore next */const
    bounds = this.state.bounds;
    return bounds[bounds.length - 1];
  }

  /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
  getPoints() {/* istanbul ignore next */var _props =
    this.props; /* istanbul ignore next */const marks = _props.marks,step = _props.step,min = _props.min,max = _props.max;
    const cache = this._getPointsCache;
    if (!cache || cache.marks !== marks || cache.step !== step) {
      const pointsObject = /* istanbul ignore next */Object.assign({}, marks);
      if (step !== null) {
        for (let point = min; point <= max; point += step) {
          pointsObject[point] = point;
        }
      }
      const points = Object.keys(pointsObject).map(parseFloat);
      points.sort((a, b) => a - b);
      this._getPointsCache = { marks, step, points };
    }
    return this._getPointsCache.points;
  }

  pushSurroundingHandles(bounds, handle, originalValue) {/* istanbul ignore next */const
    threshold = this.props.pushable;
    const value = bounds[handle];

    let direction = 0;
    if (bounds[handle + 1] - value < threshold) {
      direction = +1; // push to right
    }
    if (value - bounds[handle - 1] < threshold) {
      direction = -1; // push to left
    }

    if (direction === 0) {return;}

    const nextHandle = handle + direction;
    const diffToNext = direction * (bounds[nextHandle] - value);
    if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
      // revert to original value if pushing is impossible
      bounds[handle] = originalValue;
    }
  }

  pushHandle(bounds, handle, direction, amount) {
    const originalValue = bounds[handle];
    let currentValue = bounds[handle];
    while (direction * (currentValue - originalValue) < amount) {
      if (!this.pushHandleOnePoint(bounds, handle, direction)) {
        // can't push handle enough to create the needed `amount` gap, so we
        // revert its position to the original value
        bounds[handle] = originalValue;
        return false;
      }
      currentValue = bounds[handle];
    }
    // the handle was pushed enough to create the needed `amount` gap
    return true;
  }

  pushHandleOnePoint(bounds, handle, direction) {
    const points = this.getPoints();
    const pointIndex = points.indexOf(bounds[handle]);
    const nextPointIndex = pointIndex + direction;
    if (nextPointIndex >= points.length || nextPointIndex < 0) {
      // reached the minimum or maximum available point, can't push anymore
      return false;
    }
    const nextHandle = handle + direction;
    const nextValue = points[nextPointIndex]; /* istanbul ignore next */const
    threshold = this.props.pushable;
    const diffToNext = direction * (bounds[nextHandle] - nextValue);
    if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
      // couldn't push next handle, so we won't push this one either
      return false;
    }
    // push the handle
    bounds[handle] = nextValue;
    return true;
  }

  trimAlignValue(v, nextProps = {}) {
    const mergedProps = /* istanbul ignore next */Object.assign({}, this.props, nextProps);
    const valInRange = utils.ensureValueInRange(v, mergedProps);
    const valNotConflict = this.ensureValueNotConflict(valInRange, mergedProps);
    return utils.ensureValuePrecision(valNotConflict, mergedProps);
  }

  ensureValueNotConflict(val, { allowCross }) {
    const state = this.state || {}; /* istanbul ignore next */const
    handle = state.handle,bounds = state.bounds;
    /* eslint-disable eqeqeq */
    if (!allowCross && handle != null) {
      if (handle > 0 && val <= bounds[handle - 1]) {
        return bounds[handle - 1];
      }
      if (handle < bounds.length - 1 && val >= bounds[handle + 1]) {
        return bounds[handle + 1];
      }
    }
    /* eslint-enable eqeqeq */
    return val;
  }

  render() {/* istanbul ignore next */var _state2 =



    this.state; /* istanbul ignore next */const handle = _state2.handle,bounds = _state2.bounds; /* istanbul ignore next */var _props2 =






    this.props; /* istanbul ignore next */const prefixCls = _props2.prefixCls,vertical = _props2.vertical,included = _props2.included,disabled = _props2.disabled,handleGenerator = _props2.handle;

    const offsets = bounds.map(v => this.calcOffset(v));

    const handleClassName = `${prefixCls}-handle`;
    const handles = bounds.map((v, i) => handleGenerator({
      className: /* istanbul ignore next */(0, _classnames2.default)({
        [handleClassName]: true,
        [`${handleClassName}-${i + 1}`]: true }),

      vertical,
      offset: offsets[i],
      value: v,
      dragging: handle === i,
      index: i,
      disabled,
      ref: h => this.saveHandle(i, h) }));


    const tracks = bounds.slice(0, -1).map((_, index) => {
      const i = index + 1;
      const trackClassName = /* istanbul ignore next */(0, _classnames2.default)({
        [`${prefixCls}-track`]: true,
        [`${prefixCls}-track-${i}`]: true });

      return (
        /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_track2.default, /* istanbul ignore next */{
          className: trackClassName,
          vertical: vertical,
          included: included,
          offset: offsets[i - 1],
          length: offsets[i] - offsets[i - 1],
          key: i, __source: { fileName: _jsxFileName, lineNumber: 311 }, __self: this }));


    });

    return { tracks, handles };
  }} /* istanbul ignore next */Range.displayName = 'Range'; /* istanbul ignore next */Range.propTypes = { defaultValue: /* istanbul ignore next */_react.PropTypes.arrayOf( /* istanbul ignore next */_react.PropTypes.number), value: /* istanbul ignore next */_react.PropTypes.arrayOf( /* istanbul ignore next */_react.PropTypes.number), count: /* istanbul ignore next */_react.PropTypes.number, pushable: /* istanbul ignore next */_react.PropTypes.oneOfType([/* istanbul ignore next */_react.PropTypes.bool, /* istanbul ignore next */_react.PropTypes.number]), allowCross: /* istanbul ignore next */_react.PropTypes.bool, disabled: /* istanbul ignore next */_react.PropTypes.bool }; /* istanbul ignore next */Range.defaultProps = { count: 1, allowCross: true, pushable: false }; /* istanbul ignore next */exports.default =


/* istanbul ignore next */(0, _createSlider2.default)(Range);