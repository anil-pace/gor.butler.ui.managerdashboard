/* istanbul ignore next */'use strict';Object.defineProperty(exports, "__esModule", { value: true });var _jsxFileName = '/Users/raja.d/GOR/gor.butler.ui.managerdashboard/src/App.js';
var /* istanbul ignore next */_react = require('react'); /* istanbul ignore next */var _react2 = _interopRequireDefault(_react);
var /* istanbul ignore next */_tabs = require('./containers/tabs'); /* istanbul ignore next */var _tabs2 = _interopRequireDefault(_tabs);
var /* istanbul ignore next */_header = require('./components/header/header'); /* istanbul ignore next */var _header2 = _interopRequireDefault(_header);
var /* istanbul ignore next */_socketActions = require('./actions/socketActions');
var /* istanbul ignore next */_loginAction = require('./actions/loginAction');
var /* istanbul ignore next */_frontEndConstants = require('./constants/frontEndConstants');

var /* istanbul ignore next */_messageConstants = require('./constants/messageConstants');
var /* istanbul ignore next */_initData = require('./constants/initData.js');
var /* istanbul ignore next */_configConstants = require('./constants/configConstants');
var /* istanbul ignore next */_tabSelectAction = require('./actions/tabSelectAction');
var /* istanbul ignore next */_reactRedux = require('react-redux');
var /* istanbul ignore next */_topnotify = require('./components/topnotify/topnotify'); /* istanbul ignore next */var _topnotify2 = _interopRequireDefault(_topnotify);
var /* istanbul ignore next */_validationActions = require('./actions/validationActions');
var /* istanbul ignore next */_userActions = require('./actions/userActions');
var /* istanbul ignore next */_reactIntl = require('react-intl'); /* istanbul ignore next */function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}


class App extends /* istanbul ignore next */_react2.default.Component {
  /**
                                                                        * Called once before rendering of component,used to displatch fetch action
                                                                        * @return {[type]}
                                                                        */

  constructor(props)
  {
    super(props);
    this.state = { fetchedConfig: false };
  }

  componentWillMount() {
    if (this.props.location.pathname !== '/') {
      sessionStorage.setItem("nextUrl", this.props.location.pathname.concat(this.props.location.search));
    }

    this.context.router.push("/login");
    this.props.updateSubscriptionPacket( /* istanbul ignore next */_initData.wsOverviewData);
  }

  _getConfig() {
    let request = {
      'url': /* istanbul ignore next */_configConstants.GET_MD_CONFIG_URL,
      'method': /* istanbul ignore next */_frontEndConstants.GET,
      'cause': /* istanbul ignore next */_frontEndConstants.GET_CONFIGS,
      'contentType': /* istanbul ignore next */_frontEndConstants.APP_JSON,
      'accept': /* istanbul ignore next */_frontEndConstants.APP_JSON,
      'token': this.props.auth_token,
      'sync': true };

    this.props.userRequest(request);
  }
  componentDidMount() {
    var timeOffset = sessionStorage.getItem("timeOffset");
    if (!timeOffset) {
      let timeOffsetParams = {
        'url': /* istanbul ignore next */_configConstants.TIME_ZONE_URL,
        'method': /* istanbul ignore next */_frontEndConstants.GET,
        'cause': /* istanbul ignore next */_frontEndConstants.RECIEVE_TIME_OFFSET };

      this.props.getTimeOffSetData(timeOffsetParams);
    } else
    {
      this.props.setTimeOffSetData(timeOffset);
    }

    if (this.props.timeOutDuration) {
      let durationInMilliSeconds = this.props.timeOutDuration * 1000;

      // trigger auto logout after time duration.
      setTimeout(function () {
        sessionStorage.clear();
        this.props.userLogout();
        this.props.endConnect();
        this.props.notifyInfo( /* istanbul ignore next */_messageConstants.AUTO_LOGOUT);
      }.bind(this), durationInMilliSeconds);
    }
  }

  componentWillReceiveProps(nextProps) {
    /**
                                         * Checking if the user is loggedin 
                                         * and redirecting to main page
                                         */


    let loginAuthorized = nextProps.loginAuthorized,
    authToken = nextProps.authToken,
    socketStatus = nextProps.socketStatus,
    /**
                                            * Gaurav Makkar
                                            * In case of navigation where the user might not
                                            * click the navigation tabs i,e BACK/FORWARD button
                                            * currentTab/subtab may cause the problem
                                            * with updated packet. So picking the current tab from the
                                            * props instead of picking it from sessionStorage.
                                            * @type {string}
                                            */

    currTab = nextProps.location.pathname.substring(1, nextProps.location.pathname.length);

    if (!loginAuthorized) {
      this.context.router.push("/login");
      return;
    }
    let subscribeData;
    if (currTab) {
      subscribeData = nextProps.wsSubscriptionData[currTab] || nextProps.wsSubscriptionData["default"];
    } else

    {
      subscribeData = nextProps.wsSubscriptionData["default"];
    }

    if (!socketStatus) {
      if (!this.state.fetchedConfig) {
        this._getConfig();
        this.setState({ fetchedConfig: true });
      }
      this.props.initWebSocket();
    } else
    if (!nextProps.socketAuthorized) {
      let webSocketData = {
        'type': 'auth',
        'data': {
          "auth_token": authToken } };


      this.props.sendAuthToSocket(webSocketData);
      // this.props.initDataSentCall(subscribeData) ;
    } else
    if (!nextProps.prevTab) {
      // this.props.initDataSentCall(subscribeData) ;
      this.props.prevTabSelected(currTab || /* istanbul ignore next */_frontEndConstants.TAB_ROUTE_MAP[/* istanbul ignore next */_frontEndConstants.OVERVIEW]);
    } else
    if (nextProps.prevTab === currTab && nextProps.location.pathname === this.props.location.pathname) {
      //  this.props.initDataSentCall(subscribeData) ;
    }
  }
  /**Render method called when component react renders
     * @return {[type]}
     */
  render() {
    return (

      /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */'div', /* istanbul ignore next */{ className: 'mainContainer', __source: { fileName: _jsxFileName, lineNumber: 146 }, __self: this },
        /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_topnotify2.default, /* istanbul ignore next */{ __source: { fileName: _jsxFileName, lineNumber: 147 }, __self: this }),
        /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_header2.default, /* istanbul ignore next */{ __source: { fileName: _jsxFileName, lineNumber: 148 }, __self: this }),
        /* istanbul ignore next */_react2.default.createElement( /* istanbul ignore next */_tabs2.default, /* istanbul ignore next */{ __source: { fileName: _jsxFileName, lineNumber: 149 }, __self: this }),
        this.props.children));



  }}
;
/**
   * [Passing Router to component through context]
   * @type {Object}
   */
App.contextTypes = {
  router: /* istanbul ignore next */_react2.default.PropTypes.object.isRequired

  /**
                                                                                 * Function to pass state values as props
                                                                                 */ };


function mapStateToProps(state, ownProps) {
  return {
    authToken: state.authLogin.auth_token,
    loginAuthorized: state.authLogin.loginAuthorized,
    timeOutDuration: state.authLogin.timeOutDuration,
    socketStatus: state.recieveSocketActions.socketConnected,
    socketAuthorized: state.recieveSocketActions.socketAuthorized,
    headerInfo: state.headerData.headerInfo,
    intl: state.intl,
    tab: state.tabSelected.tab,
    subTab: state.tabSelected.subTab,
    prevTab: state.tabSelected.prevTab,
    wsSubscriptionData: state.recieveSocketActions.socketDataSubscriptionPacket || /* istanbul ignore next */_initData.wsOverviewData,
    isFilterApplied: state.filterInfo.isFilterApplied || false };



}
/**
   * Function to dispatch action values as props
   */
function mapDispatchToProps(dispatch) {
  return {
    initWebSocket: function /* istanbul ignore next */initWebSocket() {dispatch( /* istanbul ignore next */(0, _socketActions.setWsAction)({ type: /* istanbul ignore next */_frontEndConstants.WS_CONNECT }));},
    sendAuthToSocket: function /* istanbul ignore next */sendAuthToSocket(data) {dispatch( /* istanbul ignore next */(0, _socketActions.setWsAction)({ type: /* istanbul ignore next */_frontEndConstants.WS_ONSEND, data: data }));},
    initDataSentCall: function /* istanbul ignore next */initDataSentCall(data) {dispatch( /* istanbul ignore next */(0, _socketActions.setWsAction)({ type: /* istanbul ignore next */_frontEndConstants.WS_ONSEND, data: data }));},
    initMockData: function /* istanbul ignore next */initMockData(data) {dispatch( /* istanbul ignore next */(0, _socketActions.setMockAction)({ type: /* istanbul ignore next */_frontEndConstants.WS_MOCK, data: data }));},
    prevTabSelected: function /* istanbul ignore next */prevTabSelected(data) {dispatch( /* istanbul ignore next */(0, _tabSelectAction.prevTabSelected)(data));},
    getTimeOffSetData: function /* istanbul ignore next */getTimeOffSetData(data) {dispatch( /* istanbul ignore next */(0, _loginAction.getTimeOffSetData)(data));},
    setTimeOffSetData: function /* istanbul ignore next */setTimeOffSetData(data) {dispatch( /* istanbul ignore next */(0, _loginAction.setTimeOffSetData)(data));},
    endConnect: function /* istanbul ignore next */endConnect() {dispatch( /* istanbul ignore next */(0, _socketActions.endWsAction)());},
    userLogout: function /* istanbul ignore next */userLogout() {dispatch( /* istanbul ignore next */(0, _loginAction.logoutRequest)());},
    notifyInfo: function /* istanbul ignore next */notifyInfo(data) {dispatch( /* istanbul ignore next */(0, _validationActions.notifyInfo)(data));},
    updateSubscriptionPacket: function /* istanbul ignore next */updateSubscriptionPacket(data) {dispatch( /* istanbul ignore next */(0, _socketActions.updateSubscriptionPacket)(data));},
    userRequest: function /* istanbul ignore next */userRequest(data) {
      dispatch( /* istanbul ignore next */(0, _userActions.userRequest)(data));
    } };

}; /* istanbul ignore next */exports.default =
/* istanbul ignore next */(0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(App);